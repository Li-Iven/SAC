(* Лабораторная работа 7
Матрицы, СЛАУ (Wolfram)

Взять задание Sage лабы 2.3 (приведение уравнения поверхности в пространстве к каноническому виду) и выполнить без части по LaTeX.

Должно быть:
		задание системы уравнений для поиска собс. чисел в общем виде,
		получение слау не вручную, а через матричные операции умножения,
		решение этой системы,
		получение характеристического полинома через определитель,
		автоматизированное сравнение с хар. полиномом по встроенным функциям Wolfram,
		решение хар. полинома и получение таким образом собс. чисел,
		автоматизированная проверка собственных чисел с встроенными в Wolfram функциями по получению собс. чисел,
		аналогично для собс. векторов.
		График для исходного,
		график для уравнения в каноническом виде.*)

In[1]:= Clear[f]
f[x_,y_,z_]= 7*x^2 + 8*x*y + 3*y^2 + 8*x*z + 6*y*z + 3*z^2 + 6*x + y + 7;
f[x, y, z] // TraditionalForm

In[4]:= (* Постороим исходную фигуру: *)
ContourPlot3D [f[x, y, z]==0, {x, -30, 10}, {y, -30, 10}, {z, -10, 30}]

(* Для приведения поверхности к каноническому виду надо сначала вычислить ортогональные инварианты.

Пусть общее уравнение поверхности второго порядка будет выгялдеть так: *)

In[5]:= 
func[x_,y_,z_] := a11*x^2 + a22*y^2 + a33*z^2 + 2*a12*x*y  + 2*a13*x*z + 2*a23*y*z  + 2*a1*x + 2*a2*y + 2*a3*z + a0 ;
func[x,y,z]==0 // TraditionalForm

In[7]:= (* Тогда матрица квадратичной формулы будет выглядеть так: *)
A0 =  {
   {a11, a12 , a13},
   {a12 , a22 , a23},
   {a13 , a23 , a33}
};
A = {
        {7, 4, 4},
        {4, 3, 3},
        {4, 3, 3}
};
A0 // MatrixForm
A // MatrixForm

In[11]:= (* Далее надо найти собственные значения матрицы A. Для этого составляем характеристическое уравнение: *)
AE = A - IdentityMatrix[3] * l;
myCharPoly = Det[AE];
myCharPoly // TraditionalForm


In[14]:= (* Найдём характеристическое уравнение через встроенную функцию: *)
autoCharPoly = CharacteristicPolynomial[A, l]

In[15]:= (* Сравним полученные хар. уравнения: *)
FullSimplify[myCharPoly == autoCharPoly]

In[16]:= (* Теперь найдём собственные значения: *)
sols  = Solve[myCharPoly ==0, l]

In[17]:= roots = l /.sols

In[18]:= (* Запишем их в численном виде: *)
rootsNum = N[roots]

In[19]:= (* Найдём собственные значения через встроенную функцию: *)
autoRoots = Eigenvalues[A]

In[20]:= (* Как мы видим, порядок найденных с.з. отличается, так что, чтобы сравнить наши два списка с.з. надо отсортировать их: *)
Sort[roots] == Sort[autoRoots]

(* Собственные значения совпали. *)

In[21]:= (* Найдём собственные векторы матрицы A.*)
X = {x,y,z};
AE = A - IdentityMatrix[3] * l;

In[169]:= (* Составим СЛАУ для нахождения первого собственного вектора. *)
S1 = AE /. l-> roots[[1]];
S11 = S1.X;

In[23]:= myVector1 = Solve[S11 == 0 /. z->1]
myVector1 = {x, y, 1} /. myVector1[[1]]

(* Для второго и третьего аналогично: *)

In[25]:= S2 = AE /. l-> roots[[2]];
S22 = S2.X;
myVector2 = Solve[S22 == 0 /. z->1];
myVector2 = {x, y, 1} /. myVector2[[1]]

S3 = AE /. l-> roots[[3]];
S33 = S3.X;
myVector3 = Solve[S33 == 0 /. z->1];
myVector3 = {x, y, 1} /. myVector3[[1]]

In[36]:= (* Найдем собственные векторы с помощью встроенной функции: *)
autoVectors = Eigenvectors[A]

In[37]:= (* Как мы видим, нам вернулись с.в. 
Но сортировать списки списков довольно сложно, поэтому вручную укажем индексы и попарно сравним с.в.: *)
autoVectors[[3]] == myVector1
autoVectors[[2]] == myVector2
autoVectors[[1]] == myVector3

(* Результаты совпали,значит все собственные векторы найдены верно. *)

In[40]:= (* Вычислим ортогональные инварианты: *)

B = {
    {7, 4, 4, 3},
    {4, 3, 3, 0.5},
    {4, 3, 3, 0},
    {3, 0.5, 0, 7}
};


Tmp= A[[;;,{1,3}]];
tau2 = Det[A[[1;;2,1;;2]]] + Det[Tmp[[{1,3}]]] + Det[A[[2;;3, 2;;3]]]
delta = Det[A]
Delta = Det[B]

In[45]:= (* Теперь вычисляем коэффициенты канонического уравнения: *)

a = N[Sqrt[(-1)*Delta/(rootsNum[[2]]^2*tau2)]];
b = N[Sqrt[(-1)*Delta/(rootsNum[[3]]^2*tau2)]];


In[47]:= (* Построим каноническое уравнение: *)


canonical[x1_, y1_, z1_] = x1^2/a + y1^2/b - 2*z1;
canonical[x1, y1, z1]// TraditionalForm

In[49]:= (* Построим полученную упрощённую поверхность: *)
ContourPlot3D[canonical[x, y, z] == 0, {x, -30, 10}, {y, -30, 10}, {z, -10, 30}]